# logs
- clocked in 12:15
- revised the notes and logs of 06-11-25
- kill old open file for serial port connection using:
    sudo lsof /dev/ttyUSB0
    sudo kill 12345
- tried booting from manufacturer sd card didnt load anything
- tried understanding ptp4l tool and PTP protocol
- switch to root user to use ptp4l
- tried running ptp4l command terminal locked, need to find a way to use two terminals or run it as background
- clock out 16:19

# notes
- good article on PTP https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-configuring_ptp_using_ptp4l

- PTP vs NTP
    - PTP has over the Network Time Protocol (NTP) is hardware support present in various network interface controllers (NIC) and network switches.
    - This specialized hardware allows PTP to account for delays in message transfer, and greatly improves the accuracy of time synchronization. 
    - Time synchronization in larger networks where not all of the networking hardware supports PTP might be better suited for NTP.

- how it works ?
    - With hardware PTP support, the NIC has its own on-board clock, which is used to time stamp the received and transmitted PTP messages.
    - It is this on-board clock that is synchronized to the PTP master, and the computerâ€™s system clock is synchronized to the PTP hardware clock on the NIC.
    - Hardware PTP support provides better accuracy since the NIC can time stamp the PTP packets at the exact moment they are sent and received while software PTP support requires additional processing of the PTP packets by the operating system.

- using ptp
    - In order to use PTP, the kernel network driver for the intended interface has to support either software or hardware time stamping capabilities.
    - The best way to verify the time stamping capabilities of a particular driver and NIC is to use the ethtool utility to query the interface.

- starting ptp4l
    - ptp4l program can be started from the command line or it can be started as a service.
    - Options required for use both by the service and on the command line should be specified in the /etc/ptp4l.conf file.
    - The /etc/sysconfig/ptp4l file includes the -f /etc/ptp4l.conf command line option, which causes the ptp4l program to read the /etc/ptp4l.conf file and process the options it contains.
    - To start ptp4l as a service, issue the following command as root: # systemctl start ptp4l

    - ptp4l program tries to use hardware time stamping by default, To use ptp4l with hardware time stamping capable drivers and NICs, you must provide the network interface to use with the -i option
    - Using ptp4l From The Command Line, Enter the following command as root: # ptp4l -i eth3 -m

-   #ptp4l -i eth3 -m
    selected eth3 as PTP clock
    port 1: INITIALIZING to LISTENING on INITIALIZE
    port 0: INITIALIZING to LISTENING on INITIALIZE
    port 1: new foreign master 00a069.fffe.0b552d-1 selected best master clock 00a069.fffe.0b552d
    port 1: LISTENING to UNCALIBRATED on RS_SLAVE
    master offset -23947 s0 freq +0 path delay    11350
    master offset -28867 s0 freq +0 path delay    11236
    master offset -32801 s0 freq +0 path delay    10841
    master offset -37203 s1 freq +0 path delay    10583
    master offset -7275 s2 freq -30575 path delay  10583
    port 1: UNCALIBRATED to SLAVE on MASTER_CLOCK_SELECTED
    master offset -4552 s2 freq -30035 path delay  10385 
        - The master offset value is the measured offset from the master in nanoseconds.
        - The s0, s1, s2 strings indicate the different clock servo states: s0 is unlocked, s1 is clock step and s2 is locked.
        - Once the servo is in the locked state (s2), the clock will not be stepped (only slowly adjusted) unless the pi_offset_const option is set to a positive value in the configuration file (described in the ptp4l(8) man page).
        - The adj value is the frequency adjustment of the clock in parts per billion (ppb).
        - The path delay value is the estimated delay of the synchronization messages sent from the master in nanoseconds.
        - Port 0 is a Unix domain socket used for local PTP management.
        - Port 1 is the eth3 interface (based on the example above.) INITIALIZING, LISTENING, UNCALIBRATED and SLAVE are some of possible port states which change on the INITIALIZE, RS_SLAVE, MASTER_CLOCK_SELECTED events.
        - In the last state change message, the port state changed from UNCALIBRATED to SLAVE indicating successful synchronization with a PTP master clock.
        - By default, messages are sent to /var/log/messages. However, specifying the -m option enables logging to standard output which can be useful for debugging purposes.

- To enable software time stamping, the -S option needs to be used as follows: # ptp4l -i eth3 -m -S
- two different delay measurement mechanisms 
    - The -P selects the peer-to-peer (P2P) delay measurement mechanism: The P2P mechanism is preferred as it reacts to changes in the network topology faster, and may be more accurate in measuring the delay, than other mechanisms. The P2P mechanism can only be used in topologies where each port exchanges PTP messages with at most one other P2P port. It must be supported and used by all hardware, including transparent clocks, on the communication path.
    - -E selects the end-to-end (E2E) delay measurement mechanism. This is the default. The E2E mechanism is also referred to as the delay "request-response" mechanism.
    - The -A enables automatic selection of the delay measurement mechanism. The automatic option starts ptp4l in E2E mode. It will change to P2P mode if a peer delay request is received.
    - All clocks on a single PTP communication path must use the same mechanism to measure the delay. Warnings will be printed in the following circumstances:
        - When a peer delay request is received on a port using the E2E mechanism.
        - When a E2E delay request is received on a port using the P2P mechanism.

- For sudo ptp4l -i eno0 -m
ptp4l: This is the main PTP program. It implements the PTP protocol, either as a master or a slave.
-i eno0: The i stands for interface. This tells ptp4l which network port to use for sending and receiving PTP messages, and more importantly, which hardware clock to manage.
-m: The m stands for master. This tells ptp4l to act as the master clock (the source of truth). It will not look for another master on the network; it is the master.
For sudo phc2sys -s eno0 -c CLOCK_REALTIME -w -m
phc2sys: This is a helper program. Its only job is to synchronize one clock to another. PHC to System clock.
-s eno0: The s stands for source clock. This tells phc2sys to use the PTP Hardware Clock (PHC) associated with the eno0 interface as the master time source.
-c CLOCK_REALTIME: The c stands for client clock (or destination clock). This tells phc2sys to adjust the main Linux system clock, called CLOCK_REALTIME. This is the clock that the date command shows.
-w: The w stands for wait. This is a very useful flag that tells phc2sys to wait until ptp4l reports that it is stable and synchronized before it starts copying the time.
-m: The m stands for messages. This tells phc2sys to print its progress to the console, showing you the offset between the two clocks and how it's adjusting it. This is how you see if it's working.

- What it is: eno0 is the name of one of your physical Ethernet ports on the board. In modern Linux, network interfaces are named based on their physical location. eno0 likely means "onboard Ethernet port 0".
Why it's used: PTP (Precision Time Protocol) is fundamentally a network protocol. Its purpose is to synchronize time by sending special PTP messages between devices over a network.
The key is that your NXP hardware has a special feature: the PTP Hardware Clock (PHC) is directly linked to the Ethernet controller (enetc).
When you tell ptp4l to use interface eno0 (-i eno0), you are implicitly telling it to use the specific hardware clock (ptp0) that is physically associated with that Ethernet port.
Even when you are running everything locally for a test, the tools are still designed to work through a network interface.

- Software Timestamping (-S flag)
ptp4l creates a PTP message.
It hands the message to the Linux kernel's network stack.
The kernel does some processing, and then stamps the time on the packet.
The packet continues down through the network driver to the physical hardware.
The hardware finally sends the packet out on the wire.
The problem is the delay between step 3 and step 5. This delay, called kernel latency, is unpredictable. It can be a few microseconds or many milliseconds, depending on what else the CPU is doing. This unpredictability makes software timestamps inaccurate for high-precision tasks.

Hardware Timestamping (Default, no -S flag)
ptp4l creates a PTP message.
It hands the message to the kernel and the enetc driver.
The driver tells the Ethernet hardware: "This is a PTP packet. I need you to timestamp it."
The Ethernet hardware sends the packet out on the wire. At the exact moment the electrical signal leaves the physical port, the hardware records the time from its own PTP clock (ptp0).
The hardware then reports this ultra-precise timestamp back to the driver and ptp4l.
Hardware timestamping eliminates the unpredictable kernel latency. The timestamp is taken at the last possible moment, right at the physical layer, which is why it is so accurate. This is the core feature of TSN and the reason the NXP hardware is so powerful.

- lsof: This stands for "List Open Files". It's a utility that lists all files currently opened by any running program. In Linux, almost everything is treated as a file, including hardware devices.
    - ttyUSB0: This is the file that represents your physical USB-to-serial device. When a program like picocom connects to your board, it "opens" this file to communicate.